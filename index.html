<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Illustrador Digital Pro - HTML5</title>
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        /* Panel de colores favoritos */
        #favorites-panel {
            width: 200px;
            background: #333;
            padding: 15px;
            color: white;
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 150;
        }
        #favorites-panel h3 {
            margin-top: 0;
            text-align: center;
            color: #fff;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        #add-color-btn {
            width: 100%;
            padding: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 15px;
            font-size: 14px;
        }
        #add-color-btn:hover {
            background: #0056b3;
        }
        #add-color-btn.selecting {
            background: #28a745;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        #favorites-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }
        .color-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            background: #444;
            position: relative;
        }
        .color-slot:hover {
            transform: scale(1.1);
            border-color: #fff;
        }
        .color-slot.empty {
            background: repeating-linear-gradient(45deg, #444, #444 4px, #555 4px, #555 8px);
        }
        .color-slot.empty::after {
            content: "+";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #777;
            font-size: 18px;
            font-weight: bold;
        }
        .color-slot.selected {
            border: 3px solid gold;
            box-shadow: 0 0 10px gold;
        }
        .color-slot .color-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            display: none;
            z-index: 200;
        }
        .color-slot:hover .color-tooltip {
            display: block;
        }
        #selection-instruction {
            background: #444;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
            margin-top: 10px;
            display: none;
        }
        #selection-instruction.show {
            display: block;
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        /* Opciones extras */
        #extras-section {
            margin-top: 20px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        #extras-section h4 {
            margin: 0 0 10px;
            text-align: center;
            font-size: 14px;
        }
        .extra-option {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
        }
        .extra-option input[type="checkbox"] {
            margin-right: 5px;
        }
        .extra-option input[type="radio"] {
            margin-right: 3px;
        }
        .extra-option label {
            cursor: pointer;
            flex: 1;
        }
        #lasso-line-custom-color {
            display: none;
            margin-left: 10px;
        }
        /* Contenido principal */
        #main-content {
            margin-left: 230px;
            height: 100vh;
            overflow: hidden;
        }
        #toolbar {
            background-color: #333;
            color: white;
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            position: relative;
            z-index: 200;
        }
        #toolbar button, #toolbar input, #toolbar select {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #555;
            color: white;
        }
        #toolbar button:hover {
            background-color: #666;
        }
        #toolbar button.active {
            background-color: #007bff;
            border: 2px solid #0056b3;
            font-weight: bold;
        }
        #download-btn, #copy-btn {
            background-color: gold;
            color: black;
            font-weight: bold;
        }
        #download-btn:hover, #copy-btn:hover {
            background-color: #ffd700;
        }
        #color-picker {
            width: 40px;
            height: 40px;
            padding: 0;
        }
        #canvas-container {
            position: relative;
            margin: 20px auto;
            border: 2px solid #333;
            background-color: transparent;
            overflow: hidden;
            transform-origin: 0 0;
            touch-action: none; /* Desactiva zoom nativo del browser para control custom */
        }
        #canvas-stack {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #checkerboard-canvas {
            pointer-events: none;
            z-index: 0;
            background-color: transparent;
        }
        #input-canvas {
            pointer-events: all;
            background-color: transparent;
            z-index: 10;
            cursor: crosshair;
        }
        .layer-canvas {
            pointer-events: none;
            background-color: transparent;
            z-index: 1;
        }
        #brush-preview {
            pointer-events: none;
            opacity: 0.5;
            z-index: 9;
        }
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #007bff;
            border: 1px solid white;
            z-index: 20;
        }
        /* Panel de configuraci칩n de relleno */
        .fill-settings-panel {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 300;
            min-width: 250px;
        }
        .fill-settings-panel label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .fill-settings-panel input[type="range"] {
            width: 100%;
        }
        /* Modal de tama침o de lienzo */
        #canvas-size-modal, #import-image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #canvas-size-modal .modal-content, #import-image-modal .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            min-width: 400px;
        }
        #canvas-size-modal h2, #import-image-modal h2 {
            margin-top: 0;
            color: #333;
        }
        .size-presets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        .size-preset {
            padding: 15px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .size-preset:hover {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }
        .size-preset.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }
        .custom-size {
            margin: 20px 0;
        }
        .custom-size input {
            width: 80px;
            padding: 8px;
            margin: 0 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #create-canvas-btn, #load-progress-modal-btn, #import-image-btn, #import-btn, #cancel-import-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        #create-canvas-btn:hover, #load-progress-modal-btn:hover, #import-image-btn:hover, #import-btn:hover {
            background: #218838;
        }
        #cancel-import-btn {
            background: #dc3545;
        }
        #cancel-import-btn:hover {
            background: #c82333;
        }
        #layers-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        #layers-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
            max-height: 500px;
            overflow-y: auto;
            display: none;
            z-index: 200;
            pointer-events: auto;
        }
        #layers-table {
            width: 100%;
            border-collapse: collapse;
        }
        #layers-table th, #layers-table td {
            border: 1px solid #555;
            padding: 5px;
            text-align: left;
        }
        #layers-table td:first-child {
            width: 100px;
            height: 75px;
            overflow: hidden;
            position: relative;
            background-color: #fff;
        }
        #layers-table canvas {
            display: block;
            width: 100px;
            height: 75px;
        }
        #layers-table input[type="text"] {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 2px;
        }
        #layers-table input[type="range"] {
            background: #333;
            color: white;
            width: 60px;
        }
        #layers-table button {
            padding: 4px 6px;
            margin: 2px;
            font-size: 12px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            min-width: 30px;
        }
        #layers-table button:hover {
            background: #666;
        }
        #layers-table button.visibility-btn {
            background: #28a745;
            color: white;
        }
        #layers-table button.visibility-btn.hidden {
            background: #dc3545;
            color: white;
        }
        #layers-table button.lock-btn {
            background: #28a745;
            color: white;
        }
        #layers-table button.lock-btn.locked {
            background: #dc3545;
            color: white;
        }
        #layers-table tr.active {
            background-color: gold;
            color: black;
        }
        #add-flatten-layer-btn {
            background: #6f42c1;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 5px;
        }
        #add-flatten-layer-btn:hover {
            background: #5a32a3;
        }
        /* Bot칩n de cargar progreso */
        #load-progress-btn {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 500;
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #load-progress-btn:hover {
            background: #218838;
        }
        /* Modal de progreso */
        #progress-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #progress-modal .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            min-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #progress-modal h2 {
            margin-top: 0;
            color: #333;
        }
        .progress-slots {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin: 20px 0;
        }
        .progress-slot {
            border: 2px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background: #f9f9f9;
        }
        .progress-slot h4 {
            margin: 0 0 10px;
            color: #333;
        }
        .progress-preview {
            width: 120px;
            height: 90px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            margin: 0 auto 10px;
            display: block;
            position: relative;
            overflow: hidden;
        }
        .progress-preview canvas {
            width: 100%;
            height: 100%;
        }
        .progress-slot.empty .progress-preview {
            background: repeating-linear-gradient(45deg, #e0e0e0, #e0e0e0 10px, #d0d0d0 10px, #d0d0d0 20px);
        }
        .progress-slot.empty .progress-preview::after {
            content: "Vac칤o";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            font-size: 12px;
        }
        .progress-slot button {
            padding: 5px 10px;
            margin: 2px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .progress-slot .save-btn {
            background: #007bff;
            color: white;
        }
        .progress-slot .save-btn:hover {
            background: #0056b3;
        }
        .progress-slot .load-btn {
            background: #28a745;
            color: white;
        }
        .progress-slot .load-btn:hover {
            background: #218838;
        }
        .progress-slot .load-btn:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
        }
        #close-progress-modal {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #close-progress-modal:hover {
            background: #c82333;
        }
        /* Opacidad slider oculto por defecto */
        #opacity-container {
            display: none;
        }
        #image-file {
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <!-- Panel de colores favoritos -->
    <div id="favorites-panel">
        <h3>游꿛 Colores Favoritos</h3>
        <button id="add-color-btn">A침adir Color Actual</button>
        <div id="favorites-grid">
            <!-- 24 slots de colores (4x6) -->
        </div>
        <div id="selection-instruction">
            <strong>Modo Selecci칩n</strong><br>
            Haz click en una casilla para guardar el color
        </div>
        <!-- Opciones extras -->
        <div id="extras-section">
            <h4>Opciones Extras</h4>
            <div class="extra-option">
                <input type="checkbox" id="real-time-opacity" checked>
                <label for="real-time-opacity">Mostrar Opacidad en Tiempo Real (Pincel/Lazo)</label>
            </div>
            <div class="extra-option">
                <input type="radio" name="lasso-line-style" id="lasso-line-default" value="default" checked>
                <label for="lasso-line-default">Por Defecto</label>
                <input type="radio" name="lasso-line-style" id="lasso-line-custom" value="custom">
                <label for="lasso-line-custom">Personalizado</label>
                <input type="color" id="lasso-line-custom-color" value="#000000">
            </div>
        </div>
    </div>
    <!-- Modal de selecci칩n de tama침o -->
    <div id="canvas-size-modal">
        <div class="modal-content">
            <h2>游꿛 Selecciona el tama침o de tu lienzo</h2>
            <div class="size-presets">
                <div class="size-preset active" data-width="800" data-height="600">
                    <strong>800 칑 600</strong><br>
                    <small>Est치ndar</small>
                </div>
                <div class="size-preset" data-width="1920" data-height="1080">
                    <strong>1920 칑 1080</strong><br>
                    <small>Full HD</small>
                </div>
                <div class="size-preset" data-width="1280" data-height="720">
                    <strong>1280 칑 720</strong><br>
                    <small>HD</small>
                </div>
                <div class="size-preset" data-width="3840" data-height="2160">
                    <strong>3840 칑 2160</strong><br>
                    <small>4K UHD</small>
                </div>
                <div class="size-preset" data-width="1200" data-height="1200">
                    <strong>1200 칑 1200</strong><br>
                    <small>Cuadrado Grande</small>
                </div>
                <div class="size-preset" data-width="500" data-height="500">
                    <strong>500 칑 500</strong><br>
                    <small>Cuadrado Peque침o</small>
                </div>
            </div>
            <div class="custom-size">
                <h3>Personalizado</h3>
                <input type="number" id="custom-width" placeholder="Ancho" min="100" max="5000" value="800">
                <span>칑</span>
                <input type="number" id="custom-height" placeholder="Alto" min="100" max="5000" value="600">
            </div>
            <button id="create-canvas-btn">Crear Lienzo</button>
            <button id="load-progress-modal-btn">Cargar Progreso</button>
            <button id="import-image-btn">Importar Imagen</button>
        </div>
    </div>
    <!-- Modal de importar imagen -->
    <div id="import-image-modal" style="display: none;">
        <div class="modal-content">
            <h2>游늬 Importar Imagen</h2>
            <input type="file" id="image-file" accept="image/*">
            <div class="custom-size">
                <h3>Tama침o del Lienzo</h3>
                <input type="number" id="import-width" placeholder="Ancho" min="100" max="5000">
                <span>px 칑</span>
                <input type="number" id="import-height" placeholder="Alto" min="100" max="5000">
                <span>px</span>
            </div>
            <div class="extra-option">
                <input type="checkbox" id="maintain-aspect" checked>
                <label for="maintain-aspect">Mantener proporci칩n relativa</label>
            </div>
            <button id="import-btn">Importar</button>
            <button id="cancel-import-btn">Cancelar</button>
        </div>
    </div>
    <!-- Modal de progreso -->
    <div id="progress-modal">
        <div class="modal-content">
            <h2>游 Progreso Guardado</h2>
            <div class="progress-slots">
                <div class="progress-slot" data-slot="1">
                    <h4>Slot 1</h4>
                    <canvas class="progress-preview"></canvas>
                    <button class="save-btn" onclick="illustrator.saveToSlot(1)">Guardar</button>
                    <button class="load-btn" onclick="illustrator.loadFromSlot(1)">Cargar</button>
                </div>
                <div class="progress-slot" data-slot="2">
                    <h4>Slot 2</h4>
                    <canvas class="progress-preview"></canvas>
                    <button class="save-btn" onclick="illustrator.saveToSlot(2)">Guardar</button>
                    <button class="load-btn" onclick="illustrator.loadFromSlot(2)">Cargar</button>
                </div>
                <div class="progress-slot" data-slot="3">
                    <h4>Slot 3</h4>
                    <canvas class="progress-preview"></canvas>
                    <button class="save-btn" onclick="illustrator.saveToSlot(3)">Guardar</button>
                    <button class="load-btn" onclick="illustrator.loadFromSlot(3)">Cargar</button>
                </div>
                <div class="progress-slot" data-slot="4">
                    <h4>Slot 4</h4>
                    <canvas class="progress-preview"></canvas>
                    <button class="save-btn" onclick="illustrator.saveToSlot(4)">Guardar</button>
                    <button class="load-btn" onclick="illustrator.loadFromSlot(4)">Cargar</button>
                </div>
                <div class="progress-slot" data-slot="5">
                    <h4>Slot 5</h4>
                    <canvas class="progress-preview"></canvas>
                    <button class="save-btn" onclick="illustrator.saveToSlot(5)">Guardar</button>
                    <button class="load-btn" onclick="illustrator.loadFromSlot(5)">Cargar</button>
                </div>
            </div>
            <button id="close-progress-modal" onclick="illustrator.closeProgressModal()">Cerrar</button>
        </div>
    </div>
    <div id="main-content">
        <div id="toolbar" style="display: none;">
            <button id="zoom-tool">Zoom (Z)</button>
            <button id="pan-tool">Desplazar (X)</button>
            <button id="brush-tool">Pincel (1)</button>
            <button id="eraser-tool">Borrador (2)</button>
            <button id="smudge-tool">Difuminar (4)</button>
            <button id="lasso-tool">Relleno Lazo (3)</button>
            <button id="lasso-eraser-tool">Borrador Lazo (C)</button>
            <button id="fill-tool">Relleno (5)</button>
            <input type="color" id="color-picker" value="#000000">
            <input type="range" id="brush-size" min="1" max="50" value="5" style="width: 100px;">
            <label>Tama침o: <span id="size-display">5</span></label>
            <input type="range" id="stabilizer" min="0" max="10" value="0" style="width: 100px;">
            <label>Estabilizador: <span id="stab-display">0</span></label>
            <div id="opacity-container">
                <input type="range" id="brush-opacity" min="0" max="100" value="100" style="width: 100px;">
                <label>Opacidad: <span id="opacity-display">100</span></label>
            </div>
            <button id="clear-layer">Limpiar Capa</button>
            <button id="download-btn">Descargar Imagen</button>
            <button id="copy-btn">Copiar Imagen</button>
            <button id="layers-button">Capas</button>
            <!-- Panel de configuraci칩n de relleno -->
            <div id="fill-settings-panel" class="fill-settings-panel">
                <label for="fill-tolerance">Tolerancia: <span id="tolerance-display">30</span></label>
                <input type="range" id="fill-tolerance" min="0" max="255" value="30">
                <label for="fill-alpha-tolerance">Tolerancia Alpha: <span id="alpha-tolerance-display">50</span></label>
                <input type="range" id="fill-alpha-tolerance" min="0" max="255" value="50">
                <small style="color: #ccc; font-size: 10px;">춰Tolerancia m치xima ahora es 255! 游눩</small>
            </div>
        </div>
        <div id="canvas-container" style="display: none;"></div>
        <div id="layers-panel">
            <table id="layers-table">
                <thead>
                    <tr>
                        <th>Preview</th>
                        <th>Controles</th>
                    </tr>
                </thead>
                <tbody id="layers-tbody"></tbody>
            </table>
            <button onclick="illustrator.addLayer()">+ Capa</button>
            <button id="add-flatten-layer-btn" onclick="illustrator.addFlattenLayer()">A침adir capa desde el lienzo</button>
        </div>
    </div>
    <!-- Bot칩n de cargar progreso -->
    <button id="load-progress-btn" style="display: none;">Cargar Progreso</button>
    <script>
        class DigitalIllustrator {
            constructor() {
                this.canvasContainer = document.getElementById('canvas-container');
                this.containerWidth = 800;
                this.containerHeight = 600;
                this.layers = [];
                this.activeLayerIndex = 0;
                this.currentTool = 'brush';
                this.brushSize = 5;
                this.stabilizer = 0;
                this.currentOpacity = 100; // Opacidad actual (porcentaje)
                this.color = '#000000';
                this.isDrawing = false;
                this.isLassoDrawing = false;
                this.points = [];
                this.lassoPoints = [];
                this.isLayersPanelOpen = false;
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.isPanning = false;
                this.startPanX = 0;
                this.startPanY = 0;
                this.fillTolerance = 30;
                this.fillAlphaTolerance = 50;
                // Valores individuales por herramienta
                this.toolSizes = { brush: 5, eraser: 5, smudge: 20 };
                this.toolOpacities = { brush: 100, eraser: 100, lasso: 100, 'lasso-eraser': 100, smudge: 50 };
                // Opciones extras
                this.realTimeOpacity = true;
                this.lassoLineStyle = 'default';
                this.lassoLineCustomColor = '#000000';
                // Nuevas propiedades para colores favoritos
                this.favoriteColors = Array(24).fill(null);
                this.isSelectingColorSlot = false;
                // Nuevas propiedades para el zoom mejorado
                this.zoomPivot = null;
                this.isZoomDragging = false;
                this.initialZoom = 1;
                this.initialPanX = 0;
                this.initialPanY = 0;
                this.initialMouseY = 0;
                // Nuevas para touch/pinch zoom
                this.initialDistance = 0;
                this.touchPoints = [];
                this.isPinching = false;
                // Propiedades para resize
                this.isResizing = false;
                this.resizeHandle = null;
                this.startX = 0;
                this.startY = 0;
                this.startW = 0;
                this.startH = 0;
                this.handleResizeMove = this.handleResizeMove.bind(this);
                this.stopResize = this.stopResize.bind(this);
                // Propiedades para importar imagen
                this.currentAspect = null;
                this.selectedImageData = null;
                this.initFavoritesPanel();
                this.initExtrasPanel();
                this.initCanvasSizeModal();
                this.initImportModal();
                this.initProgressSystem();
                this.initToolbar();
                this.initGlobalEvents();
            }
            initImportModal() {
                const importBtn = document.getElementById('import-image-btn');
                const importModal = document.getElementById('import-image-modal');
                const fileInput = document.getElementById('image-file');
                const widthInput = document.getElementById('import-width');
                const heightInput = document.getElementById('import-height');
                const aspectToggle = document.getElementById('maintain-aspect');
                const importConfirmBtn = document.getElementById('import-btn');
                const cancelBtn = document.getElementById('cancel-import-btn');
                importBtn.addEventListener('click', () => {
                    importModal.style.display = 'flex';
                });
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            const img = new Image();
                            img.onload = () => {
                                this.currentAspect = img.naturalWidth / img.naturalHeight;
                                widthInput.value = img.naturalWidth;
                                heightInput.value = img.naturalHeight;
                                this.selectedImageData = ev.target.result; // Guardar dataURL para importar despu칠s
                            };
                            img.src = ev.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                });
                aspectToggle.addEventListener('change', () => {
                    // El toggle solo afecta los inputs, no necesita m치s l칩gica aqu칤
                });
                widthInput.addEventListener('input', () => {
                    if (aspectToggle.checked && this.currentAspect) {
                        const newHeight = (widthInput.value / this.currentAspect);
                        heightInput.value = Math.round(newHeight);
                    }
                });
                heightInput.addEventListener('input', () => {
                    if (aspectToggle.checked && this.currentAspect) {
                        const newWidth = (heightInput.value * this.currentAspect);
                        widthInput.value = Math.round(newWidth);
                    }
                });
                importConfirmBtn.addEventListener('click', () => {
                    const w = parseInt(widthInput.value) || 800;
                    const h = parseInt(heightInput.value) || 600;
                    if (w < 100 || h < 100 || w > 5000 || h > 5000) {
                        alert('El tama침o debe estar entre 100 y 5000 p칤xeles.');
                        return;
                    }
                    if (!this.selectedImageData) {
                        alert('Por favor, selecciona una imagen.');
                        return;
                    }
                    // Cerrar modales
                    importModal.style.display = 'none';
                    document.getElementById('canvas-size-modal').style.display = 'none';
                    // Configurar y crear lienzo
                    this.containerWidth = w;
                    this.containerHeight = h;
                    this.initCanvas();
                    this.bindEvents();
                    this.updateDisplays();
                    // Dibujar imagen en la primera capa de trabajo
                    const img = new Image();
                    img.onload = () => {
                        const workLayer = this.layers[1]; // Capa 1 (trabajo)
                        workLayer.ctx.clearRect(0, 0, w, h);
                        workLayer.ctx.drawImage(img, 0, 0, w, h);
                        if (this.isLayersPanelOpen) this.updateLayerUI();
                        if (this.onCanvasCreated) this.onCanvasCreated();
                    };
                    img.src = this.selectedImageData;
                    // Mostrar UI
                    document.getElementById('toolbar').style.display = 'flex';
                    this.canvasContainer.style.display = 'block';
                });
                cancelBtn.addEventListener('click', () => {
                    importModal.style.display = 'none';
                    fileInput.value = ''; // Limpiar selecci칩n
                    widthInput.value = '';
                    heightInput.value = '';
                    this.currentAspect = null;
                    this.selectedImageData = null;
                });
            }
            initExtrasPanel() {
                // Toggle para opacidad en tiempo real
                document.getElementById('real-time-opacity').addEventListener('change', (e) => {
                    this.realTimeOpacity = e.target.checked;
                });
                // Radio buttons para estilo de l칤nea de lazo
                document.querySelectorAll('input[name="lasso-line-style"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.lassoLineStyle = e.target.value;
                        const customColorPicker = document.getElementById('lasso-line-custom-color');
                        if (e.target.value === 'custom') {
                            customColorPicker.style.display = 'inline-block';
                        } else {
                            customColorPicker.style.display = 'none';
                        }
                    });
                });
                // Color picker para l칤nea personalizada
                document.getElementById('lasso-line-custom-color').addEventListener('change', (e) => {
                    this.lassoLineCustomColor = e.target.value;
                });
            }
            initToolbar() {
                document.getElementById('zoom-tool').addEventListener('click', () => this.setTool('zoom'));
                document.getElementById('pan-tool').addEventListener('click', () => this.setTool('pan'));
                document.getElementById('brush-tool').addEventListener('click', () => this.setTool('brush'));
                document.getElementById('eraser-tool').addEventListener('click', () => this.setTool('eraser'));
                document.getElementById('smudge-tool').addEventListener('click', () => this.setTool('smudge'));
                document.getElementById('lasso-tool').addEventListener('click', () => this.setTool('lasso'));
                document.getElementById('lasso-eraser-tool').addEventListener('click', () => this.setTool('lasso-eraser'));
                document.getElementById('fill-tool').addEventListener('click', () => this.setTool('fill'));
                document.getElementById('fill-tool').addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.showFillSettings(e);
                });
                document.getElementById('download-btn').addEventListener('click', () => this.downloadImage());
                const copyBtn = document.getElementById('copy-btn');
                copyBtn.addEventListener('click', () => {
                    this.copyImage();
                    copyBtn.animate([
                        { boxShadow: '0 0 0 gold' },
                        { boxShadow: '0 0 20px gold' },
                        { boxShadow: '0 0 0 gold' }
                    ], { duration: 500 });
                });
                document.getElementById('color-picker').addEventListener('change', (e) => {
                    this.color = e.target.value;
                });
                document.getElementById('brush-size').addEventListener('input', (e) => {
                    const size = parseInt(e.target.value);
                    if (['brush', 'eraser', 'smudge'].includes(this.currentTool)) {
                        this.toolSizes[this.currentTool] = size;
                    }
                    this.brushSize = size;
                    document.getElementById('size-display').textContent = this.brushSize;
                });
                document.getElementById('stabilizer').addEventListener('input', (e) => {
                    this.stabilizer = parseInt(e.target.value);
                    document.getElementById('stab-display').textContent = this.stabilizer;
                });
                document.getElementById('brush-opacity').addEventListener('input', (e) => {
                    const opacity = parseInt(e.target.value);
                    if (['brush', 'eraser', 'lasso', 'lasso-eraser', 'smudge'].includes(this.currentTool)) {
                        this.toolOpacities[this.currentTool] = opacity;
                    }
                    this.currentOpacity = opacity;
                    document.getElementById('opacity-display').textContent = this.currentOpacity;
                });
                document.getElementById('fill-tolerance').addEventListener('input', (e) => {
                    this.fillTolerance = parseInt(e.target.value);
                    document.getElementById('tolerance-display').textContent = this.fillTolerance;
                });
                document.getElementById('fill-alpha-tolerance').addEventListener('input', (e) => {
                    this.fillAlphaTolerance = parseInt(e.target.value);
                    document.getElementById('alpha-tolerance-display').textContent = this.fillAlphaTolerance;
                });
                document.getElementById('clear-layer').addEventListener('click', () => this.clearActiveLayer());
                document.getElementById('layers-button').addEventListener('click', () => this.toggleLayersPanel());
            }
            initGlobalEvents() {
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#favorites-panel') && this.isSelectingColorSlot) {
                        this.cancelColorSelection();
                    }
                    if (!e.target.closest('#fill-settings-panel') && !e.target.closest('#fill-tool')) {
                        document.getElementById('fill-settings-panel').style.display = 'none';
                    }
                });
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    } else if (e.ctrlKey && e.key === 'y') {
                        e.preventDefault();
                        this.redo();
                    } else if (e.key === '1') {
                        e.preventDefault();
                        this.setTool('brush');
                    } else if (e.key === '2') {
                        e.preventDefault();
                        this.setTool('eraser');
                    } else if (e.key === '4') {
                        e.preventDefault();
                        this.setTool('smudge');
                    } else if (e.key === '3') {
                        e.preventDefault();
                        this.setTool('lasso');
                    } else if (e.key.toLowerCase() === 'c') {
                        e.preventDefault();
                        if (this.currentTool === 'lasso-eraser') {
                            this.setTool('lasso');
                        } else {
                            this.setTool('lasso-eraser');
                        }
                    } else if (e.key === '5') {
                        e.preventDefault();
                        this.setTool('fill');
                    } else if (e.key === 'z' || e.key === 'Z') {
                        e.preventDefault();
                        this.setTool('zoom');
                    } else if (e.key.toLowerCase() === 'x') {
                        e.preventDefault();
                        if (this.currentTool === 'pan') {
                            this.setTool('brush');
                        } else {
                            this.setTool('pan');
                        }
                    } else if (e.key === 'q' || e.key === 'Q') {
                        e.preventDefault();
                        const currentSize = this.brushSize - 1;
                        this.brushSize = Math.max(1, currentSize);
                        if (['brush', 'eraser', 'smudge'].includes(this.currentTool)) {
                            document.getElementById('brush-size').value = this.brushSize;
                        }
                        document.getElementById('size-display').textContent = this.brushSize;
                    } else if (e.key === 'w' || e.key === 'W') {
                        e.preventDefault();
                        const currentSize = this.brushSize + 1;
                        this.brushSize = Math.min(50, currentSize);
                        if (['brush', 'eraser', 'smudge'].includes(this.currentTool)) {
                            document.getElementById('brush-size').value = this.brushSize;
                        }
                        document.getElementById('size-display').textContent = this.brushSize;
                    } else if (e.key === 'a' || e.key === 'A') {
                        e.preventDefault();
                        this.stabilizer = Math.max(0, this.stabilizer - 1);
                        document.getElementById('stabilizer').value = this.stabilizer;
                        document.getElementById('stab-display').textContent = this.stabilizer;
                    } else if (e.key === 's' || e.key === 'S') {
                        e.preventDefault();
                        this.stabilizer = Math.min(10, this.stabilizer + 1);
                        document.getElementById('stabilizer').value = this.stabilizer;
                        document.getElementById('stab-display').textContent = this.stabilizer;
                    }
                });
            }
            setTool(tool) {
                // Resetear estados de dibujo al cambiar herramienta
                this.stopDrawing();
                this.stopLasso();
                this.stopZoom();
                this.stopPinch();
                this.isDrawing = false;
                this.isLassoDrawing = false;
                this.isZoomDragging = false;
                this.isPanning = false;
                this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                this.brushPreviewCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                this.currentTool = tool;
                document.querySelectorAll('#toolbar button').forEach(btn => btn.classList.remove('active'));
                if (document.getElementById(`${tool}-tool`)) {
                    document.getElementById(`${tool}-tool`).classList.add('active');
                }
                // Configurar valores individuales para size y opacity
                if (['brush', 'eraser', 'smudge'].includes(tool)) {
                    this.brushSize = this.toolSizes[tool] || 5;
                    document.getElementById('brush-size').value = this.brushSize;
                    document.getElementById('size-display').textContent = this.brushSize;
                    this.currentOpacity = this.toolOpacities[tool] || 100;
                    document.getElementById('brush-opacity').value = this.currentOpacity;
                    document.getElementById('opacity-display').textContent = this.currentOpacity;
                } else if (tool === 'lasso' || tool === 'lasso-eraser') {
                    this.brushSize = this.toolSizes.brush || 5; // Usar size de brush para lasso
                    document.getElementById('brush-size').value = this.brushSize;
                    document.getElementById('size-display').textContent = this.brushSize;
                    this.currentOpacity = this.toolOpacities[tool] || 100;
                    document.getElementById('brush-opacity').value = this.currentOpacity;
                    document.getElementById('opacity-display').textContent = this.currentOpacity;
                } else {
                    // Para otras tools, mantener 칰ltimo valor
                }
                // Mostrar/ocultar opacidad slider
                const opacityContainer = document.getElementById('opacity-container');
                if (['brush', 'eraser', 'lasso', 'lasso-eraser', 'smudge'].includes(tool)) {
                    opacityContainer.style.display = 'inline-flex';
                    opacityContainer.style.gap = '10px';
                    opacityContainer.style.alignItems = 'center';
                } else {
                    opacityContainer.style.display = 'none';
                }
                // Cambiar cursor seg칰n la herramienta
                if (tool === 'zoom') {
                    this.canvasContainer.style.cursor = 'zoom-in';
                } else if (tool === 'pan') {
                    this.canvasContainer.style.cursor = 'grab';
                } else {
                    this.canvasContainer.style.cursor = 'crosshair';
                }
            }
            initProgressSystem() {
                const loadBtn = document.getElementById('load-progress-btn');
                loadBtn.addEventListener('click', () => this.showProgressModal());
                // Mostrar bot칩n despu칠s de crear canvas
                this.onCanvasCreated = () => {
                    loadBtn.style.display = 'block';
                };
            }
            showProgressModal() {
                this.renderProgressModal();
                document.getElementById('progress-modal').style.display = 'flex';
            }
            closeProgressModal() {
                document.getElementById('progress-modal').style.display = 'none';
            }
            saveToSlot(slotIndex) {
                const state = {
                    width: this.containerWidth,
                    height: this.containerHeight,
                    layers: this.layers.map(layer => ({
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        locked: layer.locked || false,
                        isBackground: layer.isBackground,
                        dataURL: layer.canvas.toDataURL('image/png')
                    })),
                    activeLayerIndex: this.activeLayerIndex
                };
                localStorage.setItem(`progress-slot-${slotIndex}`, JSON.stringify(state));
                this.renderProgressModal();
                // Feedback
                const slot = document.querySelector(`[data-slot="${slotIndex}"]`);
                slot.animate([{ backgroundColor: '#d4edda' }, { backgroundColor: '#f9f9f9' }], { duration: 500 });
            }
            loadFromSlot(slotIndex) {
                const saved = localStorage.getItem(`progress-slot-${slotIndex}`);
                if (!saved) return;
                const state = JSON.parse(saved);
                // Confirmar sobrescribir
                if (!confirm('쯉obrescribir el progreso actual?')) return;
                // Limpiar estado actual
                this.layers.forEach(layer => {
                    if (layer.canvas) this.canvasStack.removeChild(layer.canvas);
                });
                this.layers = [];
                this.activeLayerIndex = 0;
                // Actualizar tama침o PRIMERO para que createLayer use el tama침o correcto
                this.containerWidth = state.width;
                this.containerHeight = state.height;
                this.canvasContainer.style.width = this.containerWidth + 'px';
                this.canvasContainer.style.height = this.containerHeight + 'px';
                // Recrear canvas stack
                this.canvasContainer.innerHTML = '';
                this.canvasStack = document.createElement('div');
                this.canvasStack.id = 'canvas-stack';
                this.canvasContainer.appendChild(this.canvasStack);
                // Recrear checkerboard
                this.checkerboardCanvas = document.createElement('canvas');
                this.checkerboardCanvas.id = 'checkerboard-canvas';
                this.checkerboardCanvas.width = this.containerWidth;
                this.checkerboardCanvas.height = this.containerHeight;
                this.checkerboardCanvas.style.width = '100%';
                this.checkerboardCanvas.style.height = '100%';
                this.checkerboardCanvas.style.zIndex = '0';
                this.canvasStack.appendChild(this.checkerboardCanvas);
                this.drawCheckerboard();
                // Recrear input y preview
                this.inputCanvas = document.createElement('canvas');
                this.inputCanvas.id = 'input-canvas';
                this.inputCanvas.width = this.containerWidth;
                this.inputCanvas.height = this.containerHeight;
                this.inputCanvas.style.width = '100%';
                this.inputCanvas.style.height = '100%';
                this.inputCanvas.style.zIndex = '10';
                this.canvasStack.appendChild(this.inputCanvas);
                this.inputCtx = this.inputCanvas.getContext('2d');
                this.inputCtx.lineCap = 'round';
                this.inputCtx.lineJoin = 'round';
                this.brushPreviewCanvas = document.createElement('canvas');
                this.brushPreviewCanvas.id = 'brush-preview';
                this.brushPreviewCanvas.width = this.containerWidth;
                this.brushPreviewCanvas.height = this.containerHeight;
                this.brushPreviewCanvas.style.width = '100%';
                this.brushPreviewCanvas.style.height = '100%';
                this.canvasStack.appendChild(this.brushPreviewCanvas);
                this.brushPreviewCtx = this.brushPreviewCanvas.getContext('2d');
                // Recrear layers (ahora con tama침o correcto)
                let loadedCount = 0;
                const totalLayers = state.layers.length;
                state.layers.forEach((layerData, index) => {
                    const layer = this.createLayer(layerData.name, layerData.isBackground);
                    layer.visible = layerData.visible;
                    layer.opacity = layerData.opacity;
                    layer.locked = layerData.locked || false;
                    layer.canvas.style.opacity = layerData.opacity; // FIX: Setear opacidad en el estilo del canvas
                    const img = new Image();
                    img.onload = () => {
                        layer.ctx.drawImage(img, 0, 0);
                        loadedCount++;
                        if (index === state.activeLayerIndex) {
                            this.activeLayerIndex = index;
                        }
                        this.updateLayerVisibility();
                        if (this.isLayersPanelOpen) this.updateLayerUI();
                        if (loadedCount === totalLayers) {
                            this.activeLayerIndex = Math.min(state.activeLayerIndex, this.layers.length - 1); // Asegurar 칤ndice v치lido
                            // Finalizar setup despu칠s de cargar todas las im치genes
                            this.createResizeHandles();
                            this.updateCanvasTransform();
                            this.points = [];
                            this.lassoPoints = [];
                            this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                            this.brushPreviewCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                            this.renderProgressModal();
                            // Feedback
                            const slot = document.querySelector(`[data-slot="${slotIndex}"]`);
                            slot.animate([{ backgroundColor: '#d1ecf1' }, { backgroundColor: '#f9f9f9' }], { duration: 500 });
                            // Ocultar modales y mostrar UI si es carga inicial
                            document.getElementById('canvas-size-modal').style.display = 'none';
                            document.getElementById('progress-modal').style.display = 'none';
                            document.getElementById('toolbar').style.display = 'flex';
                            this.canvasContainer.style.display = 'block';
                            this.bindEvents();
                            this.updateDisplays();
                            if (this.onCanvasCreated) this.onCanvasCreated();
                        }
                    };
                    img.onerror = () => {
                        console.error('Error loading layer image');
                        loadedCount++;
                        if (loadedCount === totalLayers) {
                            this.activeLayerIndex = Math.min(state.activeLayerIndex, this.layers.length - 1);
                            // Mismo final setup incluso con errores
                            this.createResizeHandles();
                            this.updateCanvasTransform();
                            this.points = [];
                            this.lassoPoints = [];
                            this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                            this.brushPreviewCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                            this.renderProgressModal();
                            const slot = document.querySelector(`[data-slot="${slotIndex}"]`);
                            slot.animate([{ backgroundColor: '#d1ecf1' }, { backgroundColor: '#f9f9f9' }], { duration: 500 });
                            document.getElementById('canvas-size-modal').style.display = 'none';
                            document.getElementById('progress-modal').style.display = 'none';
                            document.getElementById('toolbar').style.display = 'flex';
                            this.canvasContainer.style.display = 'block';
                            this.bindEvents();
                            this.updateDisplays();
                            if (this.onCanvasCreated) this.onCanvasCreated();
                        }
                    };
                    img.src = layerData.dataURL;
                    this.layers.push(layer);
                });
            }
            renderProgressModal() {
                const slots = [1, 2, 3, 4, 5];
                slots.forEach(slotIndex => {
                    const saved = localStorage.getItem(`progress-slot-${slotIndex}`);
                    const slotEl = document.querySelector(`[data-slot="${slotIndex}"]`);
                    const previewCanvas = slotEl.querySelector('.progress-preview');
                    const loadBtn = slotEl.querySelector('.load-btn');
                    if (saved) {
                        const state = JSON.parse(saved);
                        previewCanvas.width = 120;
                        previewCanvas.height = 90;
                        const previewCtx = previewCanvas.getContext('2d');
                        // Dibujar checkerboard peque침o inmediatamente
                        const size = 10;
                        previewCtx.fillStyle = '#f0f0f0';
                        previewCtx.fillRect(0, 0, 120, 90);
                        for (let x = 0; x < 120; x += size * 2) {
                            for (let y = 0; y < 90; y += size * 2) {
                                previewCtx.fillStyle = (Math.floor(x / (size * 2)) + Math.floor(y / (size * 2))) % 2 ? '#ccc' : '#f0f0f0';
                                previewCtx.fillRect(x, y, size, size);
                                previewCtx.fillStyle = '#f0f0f0';
                                previewCtx.fillRect(x + size, y, size, size);
                                previewCtx.fillRect(x, y + size, size * 2, size);
                            }
                        }
                        // Dibujar layers visibles (solo las visibles para preview)
                        const visibleLayers = state.layers.filter(layerData => layerData.visible);
                        if (visibleLayers.length > 0) {
                            let loadedPreview = 0;
                            visibleLayers.forEach(layerData => {
                                const img = new Image();
                                img.onload = () => {
                                    previewCtx.save();
                                    previewCtx.globalAlpha = layerData.opacity;
                                    previewCtx.drawImage(img, 0, 0, 120, 90);
                                    previewCtx.restore();
                                    loadedPreview++;
                                    // Opcional: si quieres un indicador de carga completa, pero no bloquea
                                };
                                img.onerror = () => {
                                    loadedPreview++;
                                };
                                img.src = layerData.dataURL;
                            });
                        }
                        loadBtn.disabled = false;
                        slotEl.classList.remove('empty');
                    } else {
                        previewCanvas.width = 1;
                        previewCanvas.height = 1;
                        loadBtn.disabled = true;
                        slotEl.classList.add('empty');
                    }
                });
            }
            initFavoritesPanel() {
                const addColorBtn = document.getElementById('add-color-btn');
                const instruction = document.getElementById('selection-instruction');
                this.renderFavoritesGrid();
                addColorBtn.addEventListener('click', () => {
                    if (!this.isSelectingColorSlot) {
                        this.isSelectingColorSlot = true;
                        addColorBtn.textContent = 'Cancelar Selecci칩n';
                        addColorBtn.classList.add('selecting');
                        instruction.classList.add('show');
                    } else {
                        this.cancelColorSelection();
                    }
                });
                this.loadFavoriteColors();
            }
            renderFavoritesGrid() {
                const favoritesGrid = document.getElementById('favorites-grid');
                favoritesGrid.innerHTML = '';
                this.favoriteColors.forEach((color, index) => {
                    const colorSlot = document.createElement('div');
                    colorSlot.className = `color-slot ${color ? '' : 'empty'}`;
                    if (color) {
                        colorSlot.style.backgroundColor = color;
                        colorSlot.innerHTML = `<div class="color-tooltip">${color}</div>`;
                    }
                    colorSlot.addEventListener('click', () => {
                        if (this.isSelectingColorSlot) {
                            this.favoriteColors[index] = this.color;
                            this.renderFavoritesGrid();
                            this.saveFavoriteColors();
                            this.cancelColorSelection();
                            colorSlot.animate([
                                { transform: 'scale(1)' },
                                { transform: 'scale(1.2)' },
                                { transform: 'scale(1)' }
                            ], { duration: 300 });
                        } else if (color) {
                            this.color = color;
                            document.getElementById('color-picker').value = color;
                            colorSlot.classList.add('selected');
                            setTimeout(() => {
                                colorSlot.classList.remove('selected');
                            }, 500);
                        }
                    });
                    colorSlot.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        if (color && !this.isSelectingColorSlot) {
                            this.favoriteColors[index] = null;
                            this.renderFavoritesGrid();
                            this.saveFavoriteColors();
                        }
                    });
                    favoritesGrid.appendChild(colorSlot);
                });
            }
            cancelColorSelection() {
                this.isSelectingColorSlot = false;
                document.getElementById('add-color-btn').textContent = 'A침adir Color Actual';
                document.getElementById('add-color-btn').classList.remove('selecting');
                document.getElementById('selection-instruction').classList.remove('show');
            }
            saveFavoriteColors() {
                localStorage.setItem('illustrator-favorite-colors', JSON.stringify(this.favoriteColors));
            }
            loadFavoriteColors() {
                const saved = localStorage.getItem('illustrator-favorite-colors');
                if (saved) {
                    this.favoriteColors = JSON.parse(saved);
                    this.renderFavoritesGrid();
                }
            }
            initCanvasSizeModal() {
                const modal = document.getElementById('canvas-size-modal');
                const presets = document.querySelectorAll('.size-preset');
                const createBtn = document.getElementById('create-canvas-btn');
                const loadProgressBtn = document.getElementById('load-progress-modal-btn');
                const customWidth = document.getElementById('custom-width');
                const customHeight = document.getElementById('custom-height');
                presets.forEach(preset => {
                    preset.addEventListener('click', () => {
                        presets.forEach(p => p.classList.remove('active'));
                        preset.classList.add('active');
                        customWidth.value = preset.dataset.width;
                        customHeight.value = preset.dataset.height;
                    });
                });
                createBtn.addEventListener('click', () => {
                    this.containerWidth = parseInt(customWidth.value) || 800;
                    this.containerHeight = parseInt(customHeight.value) || 600;
                    if (this.containerWidth < 100 || this.containerHeight < 100) {
                        alert('El tama침o m칤nimo es 100칑100 p칤xeles');
                        return;
                    }
                    if (this.containerWidth > 5000 || this.containerHeight > 5000) {
                        alert('El tama침o m치ximo es 5000칑5000 p칤xeles');
                        return;
                    }
                    modal.style.display = 'none';
                    document.getElementById('toolbar').style.display = 'flex';
                    this.canvasContainer.style.display = 'block';
                    this.initCanvas();
                    this.bindEvents();
                    this.updateDisplays();
                    if (this.onCanvasCreated) this.onCanvasCreated();
                });
                loadProgressBtn.addEventListener('click', () => {
                    this.showProgressModal();
                });
                customWidth.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') createBtn.click();
                });
                customHeight.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') createBtn.click();
                });
            }
            initCanvas() {
                this.canvasContainer.style.width = this.containerWidth + 'px';
                this.canvasContainer.style.height = this.containerHeight + 'px';
                this.canvasStack = document.createElement('div');
                this.canvasStack.id = 'canvas-stack';
                this.canvasContainer.innerHTML = '';
                this.canvasContainer.appendChild(this.canvasStack);
                this.checkerboardCanvas = document.createElement('canvas');
                this.checkerboardCanvas.id = 'checkerboard-canvas';
                this.checkerboardCanvas.width = this.containerWidth;
                this.checkerboardCanvas.height = this.containerHeight;
                this.checkerboardCanvas.style.width = '100%';
                this.checkerboardCanvas.style.height = '100%';
                this.checkerboardCanvas.style.zIndex = '0';
                this.canvasStack.appendChild(this.checkerboardCanvas);
                this.drawCheckerboard();
                this.inputCanvas = document.createElement('canvas');
                this.inputCanvas.id = 'input-canvas';
                this.inputCanvas.width = this.containerWidth;
                this.inputCanvas.height = this.containerHeight;
                this.inputCanvas.style.width = '100%';
                this.inputCanvas.style.height = '100%';
                this.inputCanvas.style.zIndex = '10';
                this.canvasStack.appendChild(this.inputCanvas);
                this.inputCtx = this.inputCanvas.getContext('2d');
                this.inputCtx.lineCap = 'round';
                this.inputCtx.lineJoin = 'round';
                this.brushPreviewCanvas = document.createElement('canvas');
                this.brushPreviewCanvas.id = 'brush-preview';
                this.brushPreviewCanvas.width = this.containerWidth;
                this.brushPreviewCanvas.height = this.containerHeight;
                this.brushPreviewCanvas.style.width = '100%';
                this.brushPreviewCanvas.style.height = '100%';
                this.canvasStack.appendChild(this.brushPreviewCanvas);
                this.brushPreviewCtx = this.brushPreviewCanvas.getContext('2d');
                this.initLayers();
                this.createResizeHandles();
                this.updateLayerUI();
                this.updateCanvasTransform();
            }
            createResizeHandles() {
                // Remover handles existentes
                document.querySelectorAll('.resize-handle').forEach(h => h.remove());
                const directions = ['n', 's', 'e', 'w', 'nw', 'ne', 'sw', 'se'];
                directions.forEach(dir => {
                    const handle = document.createElement('div');
                    handle.className = 'resize-handle';
                    handle.dataset.direction = dir;
                    handle.style.position = 'absolute';
                    handle.style.width = '10px';
                    handle.style.height = '10px';
                    handle.style.background = '#007bff';
                    handle.style.border = '1px solid white';
                    handle.style.cursor = this.getResizeCursor(dir);
                    switch(dir) {
                        case 'n':
                            handle.style.top = '-5px';
                            handle.style.left = '50%';
                            handle.style.transform = 'translateX(-50%)';
                            break;
                        case 's':
                            handle.style.bottom = '-5px';
                            handle.style.left = '50%';
                            handle.style.transform = 'translateX(-50%)';
                            break;
                        case 'e':
                            handle.style.right = '-5px';
                            handle.style.top = '50%';
                            handle.style.transform = 'translateY(-50%)';
                            break;
                        case 'w':
                            handle.style.left = '-5px';
                            handle.style.top = '50%';
                            handle.style.transform = 'translateY(-50%)';
                            break;
                        case 'nw':
                            handle.style.top = '-5px';
                            handle.style.left = '-5px';
                            break;
                        case 'ne':
                            handle.style.top = '-5px';
                            handle.style.right = '-5px';
                            break;
                        case 'sw':
                            handle.style.bottom = '-5px';
                            handle.style.left = '-5px';
                            break;
                        case 'se':
                            handle.style.bottom = '-5px';
                            handle.style.right = '-5px';
                            break;
                    }
                    this.canvasContainer.appendChild(handle);
                    handle.addEventListener('pointerdown', (e) => {
                        e.stopPropagation();
                        this.startResize(e, dir);
                    });
                });
            }
            getResizeCursor(dir) {
                const cursors = {
                    n: 'ns-resize',
                    s: 'ns-resize',
                    e: 'ew-resize',
                    w: 'ew-resize',
                    nw: 'nwse-resize',
                    ne: 'nesw-resize',
                    sw: 'nesw-resize',
                    se: 'nwse-resize'
                };
                return cursors[dir] || 'default';
            }
            startResize(e, dir) {
                this.resizeHandle = dir;
                this.startX = e.clientX;
                this.startY = e.clientY;
                this.startW = this.containerWidth;
                this.startH = this.containerHeight;
                this.isResizing = true;
                this.layers.forEach(layer => this.saveState(layer));
                e.target.setPointerCapture(e.pointerId);
                document.addEventListener('pointermove', this.handleResizeMove);
                document.addEventListener('pointerup', this.stopResize);
            }
            handleResizeMove(e) {
                if (!this.isResizing) return;
                let deltaX = e.clientX - this.startX;
                let deltaY = e.clientY - this.startY;
                let newWidth = this.startW;
                let newHeight = this.startH;
                let offsetX = 0;
                let offsetY = 0;
                const dir = this.resizeHandle;
                if (dir === 'e' || dir === 'ne' || dir === 'se') {
                    newWidth += deltaX;
                } else if (dir === 'w' || dir === 'nw' || dir === 'sw') {
                    newWidth -= deltaX;
                    offsetX = -deltaX;
                }
                if (dir === 's' || dir === 'se' || dir === 'sw') {
                    newHeight += deltaY;
                } else if (dir === 'n' || dir === 'ne' || dir === 'nw') {
                    newHeight -= deltaY;
                    offsetY = -deltaY;
                }
                newWidth = Math.max(100, newWidth);
                newHeight = Math.max(100, newHeight);
                this.performResize(newWidth, newHeight, offsetX, offsetY);
            }
            stopResize() {
                this.isResizing = false;
                this.resizeHandle = null;
                document.removeEventListener('pointermove', this.handleResizeMove);
                document.removeEventListener('pointerup', this.stopResize);
            }
            performResize(newW, newH, offsetX, offsetY) {
                // Resize checkerboard
                this.checkerboardCanvas.width = newW;
                this.checkerboardCanvas.height = newH;
                this.drawCheckerboard();
                // Resize layers
                this.layers.forEach(layer => {
                    const oldCanvas = layer.canvas;
                    const newCanvas = document.createElement('canvas');
                    newCanvas.width = newW;
                    newCanvas.height = newH;
                    newCanvas.style.width = '100%';
                    newCanvas.style.height = '100%';
                    newCanvas.style.zIndex = oldCanvas.style.zIndex;
                    newCanvas.className = oldCanvas.className;
                    const newCtx = newCanvas.getContext('2d');
                    if (layer.isBackground) {
                        newCtx.fillStyle = 'white';
                        newCtx.fillRect(0, 0, newW, newH);
                    } else {
                        newCtx.clearRect(0, 0, newW, newH);
                    }
                    newCtx.drawImage(oldCanvas, offsetX, offsetY);
                    this.canvasStack.replaceChild(newCanvas, oldCanvas);
                    layer.canvas = newCanvas;
                    layer.ctx = newCtx;
                });
                // Resize input
                this.inputCanvas.width = newW;
                this.inputCanvas.height = newH;
                this.inputCtx.clearRect(0, 0, newW, newH);
                // Resize preview
                this.brushPreviewCanvas.width = newW;
                this.brushPreviewCanvas.height = newH;
                this.brushPreviewCtx.clearRect(0, 0, newW, newH);
                // Update container
                this.canvasContainer.style.width = newW + 'px';
                this.canvasContainer.style.height = newH + 'px';
                this.containerWidth = newW;
                this.containerHeight = newH;
                // Adjust pan to compensate for offset
                this.panX -= offsetX * this.zoom;
                this.panY -= offsetY * this.zoom;
                this.updateCanvasTransform();
                // Update layer UI if open
                if (this.isLayersPanelOpen) this.updateLayerUI();
            }
            drawCheckerboard() {
                const ctx = this.checkerboardCanvas.getContext('2d');
                const size = 20;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, this.containerWidth, this.containerHeight);
                for (let x = 0; x < this.containerWidth; x += size * 2) {
                    for (let y = 0; y < this.containerHeight; y += size * 2) {
                        ctx.fillStyle = (Math.floor(x / (size * 2)) + Math.floor(y / (size * 2))) % 2 ? '#ccc' : '#f0f0f0';
                        ctx.fillRect(x, y, size, size);
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(x + size, y, size, size);
                        ctx.fillRect(x, y + size, size * 2, size);
                    }
                }
            }
            initLayers() {
                // Crear capa de fondo (solo para visualizaci칩n)
                const bgLayer = this.createLayer('Fondo', true);
                bgLayer.locked = true; // Fondo siempre locked
                this.layers.push(bgLayer);
                this.saveState(bgLayer);
                // Crear capa de trabajo principal autom치ticamente
                const workLayer = this.createLayer('Capa 1', false);
                this.layers.push(workLayer);
                this.saveState(workLayer);
                // Establecer la capa de trabajo como activa por defecto
                this.activeLayerIndex = 1;
                this.updateLayerVisibility();
                this.updateLayerUI();
            }
            createLayer(name, isBackground = false) {
                const canvas = document.createElement('canvas');
                canvas.className = 'layer-canvas';
                canvas.width = this.containerWidth;
                canvas.height = this.containerHeight;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.opacity = '1';
                canvas.style.backgroundColor = 'transparent';
                canvas.style.zIndex = isBackground ? '1' : `${this.layers.length + 1}`;
                this.canvasStack.appendChild(canvas);
                const ctx = canvas.getContext('2d');
                if (isBackground) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, this.containerWidth, this.containerHeight);
                } else {
                    ctx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                }
                return {
                    canvas,
                    ctx,
                    name,
                    visible: true,
                    opacity: 1.0,
                    locked: false,
                    isBackground,
                    history: [],
                    redoStack: []
                };
            }
            addLayer() {
                const newLayer = this.createLayer(`Capa ${this.layers.length + 1}`);
                this.layers.push(newLayer);
                this.saveState(newLayer);
                this.activeLayerIndex = this.layers.length - 1;
                this.updateZIndices();
                this.updateLayerUI();
                this.updateLayerVisibility();
            }
            addFlattenLayer() {
                if (this.layers.length < 2) {
                    alert('Necesitas al menos una capa para combinar.');
                    return;
                }
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.containerWidth;
                tempCanvas.height = this.containerHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                this.layers.forEach(layer => {
                    if (layer.visible && layer.name !== 'Fondo') {
                        tempCtx.save();
                        tempCtx.globalAlpha = layer.opacity;
                        tempCtx.drawImage(layer.canvas, 0, 0);
                        tempCtx.restore();
                    }
                });
                const newLayer = this.createLayer('Capa Combinada', false);
                newLayer.ctx.drawImage(tempCanvas, 0, 0);
                this.layers.push(newLayer);
                this.saveState(newLayer);
                this.activeLayerIndex = this.layers.length - 1;
                this.updateZIndices();
                this.updateLayerUI();
                this.updateLayerVisibility();
            }
            mergeWithBelow(index) {
                if (index <= 0 || this.layers.length < 2) {
                    alert('No se puede combinar la capa de fondo o sin capas inferiores.');
                    return;
                }
                const currentLayer = this.layers[index];
                const belowLayer = this.layers[index - 1];
                if (!belowLayer.visible) {
                    alert('La capa inferior debe estar visible para combinar.');
                    return;
                }
                this.saveState(currentLayer);
                this.saveState(belowLayer);
                // Dibujar current sobre below, respetando opacidad
                belowLayer.ctx.save();
                belowLayer.ctx.globalAlpha = currentLayer.opacity;
                belowLayer.ctx.drawImage(currentLayer.canvas, 0, 0);
                belowLayer.ctx.restore();
                // Limpiar current
                currentLayer.ctx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                // Actualizar opacidad de below si es necesario, pero mantener la de below
                if (this.isLayersPanelOpen) this.updateLayerUI();
                this.updateLayerVisibility();
            }
            toggleLock(index) {
                this.layers[index].locked = !this.layers[index].locked;
                this.updateLayerUI();
            }
            deleteSpecificLayer(index) {
                this.activeLayerIndex = index;
                this.deleteLayer();
            }
            deleteLayer() {
                if (this.layers.length <= 1) return;
                const layer = this.layers[this.activeLayerIndex];
                layer.history = [];
                layer.redoStack = [];
                this.canvasStack.removeChild(layer.canvas);
                this.layers.splice(this.activeLayerIndex, 1);
                this.activeLayerIndex = Math.min(this.activeLayerIndex, this.layers.length - 1);
                this.updateZIndices();
                this.updateLayerUI();
                this.updateLayerVisibility();
            }
            clearActiveLayer() {
                const layer = this.layers[this.activeLayerIndex];
                this.saveState(layer);
                layer.ctx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                if (this.isLayersPanelOpen) this.updateLayerUI();
            }
            setOpacity(index, value) {
                const opacity = value / 100;
                this.layers[index].opacity = opacity;
                this.layers[index].canvas.style.opacity = opacity;
                this.updateLayerVisibility();
            }
            async copyImage() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.containerWidth;
                tempCanvas.height = this.containerHeight;
                const tempCtx = tempCanvas.getContext('2d');
                // FONDO TRANSPARENTE
                tempCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                // Dibujar solo las capas visibles
                this.layers.forEach(layer => {
                    if (layer.visible) {
                        tempCtx.save();
                        tempCtx.globalAlpha = layer.opacity;
                        tempCtx.drawImage(layer.canvas, 0, 0);
                        tempCtx.restore();
                    }
                });
                tempCanvas.toBlob(async (blob) => {
                    const item = new ClipboardItem({ 'image/png': blob });
                    await navigator.clipboard.write([item]);
                    // Efecto visual de confirmaci칩n
                    const copyBtn = document.getElementById('copy-btn');
                    copyBtn.animate([
                        { boxShadow: '0 0 0 gold' },
                        { boxShadow: '0 0 20px gold' },
                        { boxShadow: '0 0 0 gold' }
                    ], { duration: 500 });
                }, 'image/png');
            }
            downloadImage() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.containerWidth;
                tempCanvas.height = this.containerHeight;
                const tempCtx = tempCanvas.getContext('2d');
                // FONDO TRANSPARENTE en lugar del ajedrez
                tempCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                // Dibujar solo las capas visibles
                this.layers.forEach(layer => {
                    if (layer.visible) {
                        tempCtx.save();
                        tempCtx.globalAlpha = layer.opacity;
                        tempCtx.drawImage(layer.canvas, 0, 0);
                        tempCtx.restore();
                    }
                });
                const link = document.createElement('a');
                link.download = `mi-ilustracion-${this.containerWidth}x${this.containerHeight}.png`;
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
            }
            drawCheckerboardOnCtx(ctx) {
                const size = 20;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, this.containerWidth, this.containerHeight);
                for (let x = 0; x < this.containerWidth; x += size * 2) {
                    for (let y = 0; y < this.containerHeight; y += size * 2) {
                        ctx.fillStyle = (Math.floor(x / (size * 2)) + Math.floor(y / (size * 2))) % 2 ? '#ccc' : '#f0f0f0';
                        ctx.fillRect(x, y, size, size);
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(x + size, y, size, size);
                        ctx.fillRect(x, y + size, size * 2, size);
                    }
                }
            }
            saveState(layer) {
                const data = layer.ctx.getImageData(0, 0, this.containerWidth, this.containerHeight);
                layer.history.push(data);
                layer.redoStack = [];
                if (layer.history.length > 50) layer.history.shift();
            }
            undo() {
                const layer = this.layers[this.activeLayerIndex];
                if (layer.history.length > 0) {
                    layer.redoStack.push(layer.ctx.getImageData(0, 0, this.containerWidth, this.containerHeight));
                    const prevState = layer.history.pop();
                    layer.ctx.putImageData(prevState, 0, 0);
                    if (this.isLayersPanelOpen) this.updateLayerUI();
                }
            }
            redo() {
                const layer = this.layers[this.activeLayerIndex];
                if (layer.redoStack.length > 0) {
                    layer.history.push(layer.ctx.getImageData(0, 0, this.containerWidth, this.containerHeight));
                    const nextState = layer.redoStack.pop();
                    layer.ctx.putImageData(nextState, 0, 0);
                    if (this.isLayersPanelOpen) this.updateLayerUI();
                }
            }
            renameLayer(index, name) {
                this.layers[index].name = name;
                this.updateLayerUI();
            }
            moveLayer(index, direction) {
                // FIX: Invertir l칩gica para que  suba (a mayor 칤ndice, top) y  baje
                if (direction === 'up' && index < this.layers.length - 1) {
                    [this.layers[index + 1], this.layers[index]] = [this.layers[index], this.layers[index + 1]];
                    this.activeLayerIndex = index + 1;
                } else if (direction === 'down' && index > 0) {
                    [this.layers[index - 1], this.layers[index]] = [this.layers[index], this.layers[index - 1]];
                    this.activeLayerIndex = index - 1;
                }
                this.updateZIndices();
                this.updateLayerUI();
            }
            toggleVisibility(index) {
                this.layers[index].visible = !this.layers[index].visible;
                this.updateLayerVisibility();
                this.updateLayerUI();
            }
            toggleLock(index) {
                this.layers[index].locked = !this.layers[index].locked;
                this.updateLayerUI();
            }
            updateZIndices() {
                this.layers.forEach((layer, index) => {
                    layer.canvas.style.zIndex = `${index + 1}`;
                });
            }
            updateLayerVisibility() {
                this.layers.forEach(layer => {
                    layer.canvas.style.opacity = layer.opacity; // Asegurar opacidad siempre
                    if (layer.visible) {
                        layer.canvas.style.display = 'block';
                    } else {
                        layer.canvas.style.display = 'none';
                    }
                });
            }
            updateLayerUI() {
                const tbody = document.getElementById('layers-tbody');
                tbody.innerHTML = '';
                // Renderizar en orden inverso: primera fila es la capa superior (칤ndice m치s alto)
                const reversedLayers = [...this.layers].reverse();
                reversedLayers.forEach((layer, uiIndex) => {
                    const actualIndex = this.layers.length - 1 - uiIndex;
                    const tr = document.createElement('tr');
                    if (actualIndex === this.activeLayerIndex) {
                        tr.classList.add('active');
                    }
                    const previewTd = document.createElement('td');
                    const previewCanvas = document.createElement('canvas');
                    previewCanvas.width = 100;
                    previewCanvas.height = 75;
                    const previewCtx = previewCanvas.getContext('2d');
                    this.drawCheckerboardOnCtx(previewCtx);
                    previewCtx.drawImage(layer.canvas, 0, 0, 100, 75);
                    previewTd.appendChild(previewCanvas);
                    previewTd.style.cursor = 'pointer';
                    previewTd.addEventListener('click', () => {
                        this.activeLayerIndex = actualIndex;
                        this.updateLayerUI();
                    });
                    const controlsTd = document.createElement('td');
                    const visIcon = layer.visible ? '游녜' : '游뗻';
                    const lockIcon = layer.locked ? '游' : '游댑';
                    const opacityValue = Math.round(layer.opacity * 100);
                    controlsTd.innerHTML = `
                        <input type="text" value="${layer.name}" onchange="illustrator.renameLayer(${actualIndex}, this.value)">
                        <button onclick="illustrator.moveLayer(${actualIndex}, 'up')"></button>
                        <button onclick="illustrator.moveLayer(${actualIndex}, 'down')"></button>
                        <button class="visibility-btn ${!layer.visible ? 'hidden' : ''}" onclick="illustrator.toggleVisibility(${actualIndex})">${visIcon}</button>
                        <button class="lock-btn ${layer.locked ? 'locked' : ''}" onclick="illustrator.toggleLock(${actualIndex})">${lockIcon}</button>
                        <input type="range" min="0" max="100" value="${opacityValue}" oninput="illustrator.setOpacity(${actualIndex}, this.value)">
                        <button onclick="illustrator.mergeWithBelow(${actualIndex})">Combinar con inferior</button>
                        <button onclick="illustrator.deleteSpecificLayer(${actualIndex})">Borrar</button>
                    `;
                    tr.appendChild(previewTd);
                    tr.appendChild(controlsTd);
                    tbody.appendChild(tr);
                });
            }
            getSmoothedPoints() {
                if (this.points.length <= 1) return this.points;
                const smoothed = [];
                for (let i = 0; i < this.points.length; i++) {
                    let avgX = 0, avgY = 0, count = 0;
                    const start = Math.max(0, i - this.stabilizer);
                    const end = Math.min(this.points.length - 1, i + this.stabilizer);
                    for (let j = start; j <= end; j++) {
                        avgX += this.points[j].x;
                        avgY += this.points[j].y;
                        count++;
                    }
                    smoothed.push({ x: avgX / count, y: avgY / count });
                }
                return smoothed;
            }
            drawPath(ctx, points) {
                if (points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            }
            // NUEVOS M칄TODOS PARA EL ZOOM MEJORADO
            startZoom(e) {
                const pos = this.getMousePos(e);
                this.zoomPivot = { x: pos.x, y: pos.y };
                this.initialZoom = this.zoom;
                this.initialPanX = this.panX;
                this.initialPanY = this.panY;
                this.initialMouseY = e.clientY;
                this.isZoomDragging = true;
                // Feedback visual del pivote
                this.drawZoomPivot();
            }
            handleZoomDrag(e) {
                if (!this.isZoomDragging || !this.zoomPivot) return;
                // DeltaY absoluto del mouse (arriba = zoom in)
                const deltaY = this.initialMouseY - e.clientY;
                const zoomFactor = 1 + (deltaY / 200);
                const newZoom = Math.max(0.1, Math.min(10, this.initialZoom * zoomFactor));
                if (newZoom !== this.zoom) {
                    this.zoom = newZoom;
                    // Ajuste de pan para mantener pivot fijo en screen
                    const pivotScreenX = (this.zoomPivot.x * this.initialZoom) + this.initialPanX;
                    const pivotScreenY = (this.zoomPivot.y * this.initialZoom) + this.initialPanY;
                    this.panX = pivotScreenX - (this.zoomPivot.x * this.zoom);
                    this.panY = pivotScreenY - (this.zoomPivot.y * this.zoom);
                    this.updateCanvasTransform();
                    this.drawZoomPivot();
                }
            }
            drawZoomPivot() {
                if (!this.zoomPivot) return;
                this.brushPreviewCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                // Dibuja en coords L칍GICAS del canvas
                const px = this.zoomPivot.x;
                const py = this.zoomPivot.y;
                this.brushPreviewCtx.strokeStyle = '#ff0000';
                this.brushPreviewCtx.lineWidth = 2;
                this.brushPreviewCtx.setLineDash([5, 5]);
                // Cruz en el pivot l칩gico
                this.brushPreviewCtx.beginPath();
                this.brushPreviewCtx.moveTo(px - 15, py);
                this.brushPreviewCtx.lineTo(px + 15, py);
                this.brushPreviewCtx.moveTo(px, py - 15);
                this.brushPreviewCtx.lineTo(px, py + 15);
                this.brushPreviewCtx.stroke();
                this.brushPreviewCtx.setLineDash([]);
            }
            stopZoom() {
                this.isZoomDragging = false;
                this.zoomPivot = null;
                this.brushPreviewCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
            }
            handleWheelZoom(e) {
                e.preventDefault();
                const rect = this.canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const scaleX = this.containerWidth / rect.width;
                const scaleY = this.containerHeight / rect.height;
                // Coords l칩gicas correctas (sin -pan)
                const worldX = mouseX * scaleX;
                const worldY = mouseY * scaleY;
                const oldZoom = this.zoom;
                const zoomDelta = e.deltaY < 0 ? 0.1 : -0.1;
                this.zoom = Math.max(0.1, Math.min(10, oldZoom + zoomDelta));
                // Ajuste exacto de pan para centrar en mouse
                this.panX = mouseX - (worldX * this.zoom);
                this.panY = mouseY - (worldY * this.zoom);
                this.updateCanvasTransform();
            }
            // M칄TODOS PARA PINCH ZOOM EN M칍VIL
            getTouchPos(touch) {
                const rect = this.canvasContainer.getBoundingClientRect();
                const scaleX = this.containerWidth / rect.width;
                const scaleY = this.containerHeight / rect.height;
                return {
                    x: (touch.clientX - rect.left) * scaleX,
                    y: (touch.clientY - rect.top) * scaleY
                };
            }
            startPinch(e) {
                e.preventDefault();
                this.touchPoints = Array.from(e.touches).map(t => this.getTouchPos(t));
                if (this.touchPoints.length === 2) {
                    this.initialDistance = Math.hypot(
                        this.touchPoints[0].x - this.touchPoints[1].x,
                        this.touchPoints[0].y - this.touchPoints[1].y
                    );
                    this.initialZoom = this.zoom;
                    const midX = (this.touchPoints[0].x + this.touchPoints[1].x) / 2;
                    const midY = (this.touchPoints[0].y + this.touchPoints[1].y) / 2;
                    this.initialPanX = this.panX;
                    this.initialPanY = this.panY;
                    // Ajuste inicial de pan al midpoint
                    this.panX = (this.canvasContainer.getBoundingClientRect().width / 2) - (midX * this.zoom);
                    this.panY = (this.canvasContainer.getBoundingClientRect().height / 2) - (midY * this.zoom);
                    this.isPinching = true;
                }
            }
            handlePinch(e) {
                if (!this.isPinching || e.touches.length !== 2) return;
                e.preventDefault();
                const currentPoints = Array.from(e.touches).map(t => this.getTouchPos(t));
                const currentDistance = Math.hypot(
                    currentPoints[0].x - currentPoints[1].x,
                    currentPoints[0].y - currentPoints[1].y
                );
                const scale = currentDistance / this.initialDistance;
                const newZoom = Math.max(0.1, Math.min(10, this.initialZoom * scale));
                if (newZoom !== this.zoom) {
                    this.zoom = newZoom;
                    const midX = (currentPoints[0].x + currentPoints[1].x) / 2;
                    const midY = (currentPoints[0].y + currentPoints[1].y) / 2;
                    this.panX = (this.canvasContainer.getBoundingClientRect().width / 2) - (midX * this.zoom);
                    this.panY = (this.canvasContainer.getBoundingClientRect().height / 2) - (midY * this.zoom);
                    this.updateCanvasTransform();
                }
            }
            stopPinch() {
                this.isPinching = false;
                this.touchPoints = [];
                this.initialDistance = 0;
            }
            handleTouchStart(e) {
                if (e.touches.length > 1 && this.currentTool === 'zoom') {
                    this.startPinch(e);
                } else if (this.currentTool === 'fill') {
                    this.fillArea(e.touches[0]);
                }
            }
            handleTouchMove(e) {
                if (this.isPinching) {
                    this.handlePinch(e);
                }
            }
            handleTouchEnd(e) {
                if (this.isPinching) {
                    this.stopPinch();
                }
            }
            bindEvents() {
                // Unbind previous canvas listeners to prevent multiples
                this.canvasContainer.removeEventListener('wheel', this.handleWheel);
                this.canvasContainer.removeEventListener('pointerdown', this.handlePointerDown);
                this.canvasContainer.removeEventListener('pointermove', this.handlePointerMove);
                this.canvasContainer.removeEventListener('pointerup', this.handlePointerUp);
                this.canvasContainer.removeEventListener('pointerleave', this.handlePointerLeave);
                this.canvasContainer.removeEventListener('contextmenu', this.handleContextMenu);
                this.canvasContainer.removeEventListener('touchstart', this.handleTouchStart);
                this.canvasContainer.removeEventListener('touchmove', this.handleTouchMove);
                this.canvasContainer.removeEventListener('touchend', this.handleTouchEnd);
                // Bind new ones
                this.canvasContainer.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
                this.canvasContainer.addEventListener('pointerdown', this.handlePointerDown.bind(this));
                this.canvasContainer.addEventListener('pointermove', this.handlePointerMove.bind(this));
                this.canvasContainer.addEventListener('pointerup', this.handlePointerUp.bind(this));
                this.canvasContainer.addEventListener('pointerleave', this.handlePointerLeave.bind(this));
                this.canvasContainer.addEventListener('contextmenu', this.handleContextMenu.bind(this));
                this.canvasContainer.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvasContainer.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvasContainer.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                // Legacy touch for inputCanvas (new each time)
                this.inputCanvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.currentTool === 'lasso' || this.currentTool === 'lasso-eraser') this.startLasso(e.touches[0]);
                    else if (['brush', 'eraser', 'smudge'].includes(this.currentTool)) this.startDrawing(e.touches[0]);
                });
                this.inputCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.isLassoDrawing) this.drawLasso(e.touches[0]);
                    else if (this.isDrawing && ['brush', 'eraser', 'smudge'].includes(this.currentTool)) this.draw(e.touches[0]);
                });
                this.inputCanvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.isLassoDrawing) this.stopLasso();
                    else this.stopDrawing();
                });
            }
            handleWheel(e) {
                e.preventDefault();
                if (this.currentTool === 'zoom') {
                    this.handleWheelZoom(e);
                } else {
                    // Zoom normal para otras herramientas
                    const rect = this.canvasContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const scaleX = this.containerWidth / rect.width;
                    const scaleY = this.containerHeight / rect.height;
                    const worldX = mouseX * scaleX;
                    const worldY = mouseY * scaleY;
                    const oldZoom = this.zoom;
                    const zoomDelta = e.deltaY < 0 ? 0.1 : -0.1;
                    this.zoom = Math.max(0.1, Math.min(10, oldZoom + zoomDelta));
                    this.panX = mouseX - (worldX * this.zoom);
                    this.panY = mouseY - (worldY * this.zoom);
                    this.updateCanvasTransform();
                }
            }
            handleContextMenu(e) {
                e.preventDefault();
            }
            handlePointerDown(e) {
                if (e.pointerType === 'touch' && e.touches && e.touches.length > 1) {
                    // Multi-touch para pinch (solo si >1 toque)
                    this.startPinch(e);
                    return;
                }
                // Simula button para pointer (0=izq, 2=der)
                const simButton = e.button || (e.pointerType === 'touch' ? 0 : e.button);
                if ((simButton === 2 || (this.currentTool === 'pan' && simButton === 0)) && !this.isPanning) {
                    this.isPanning = true;
                    this.startPanX = e.clientX;
                    this.startPanY = e.clientY;
                    this.canvasContainer.style.cursor = 'grabbing';
                    e.preventDefault();
                } else if (simButton === 0) {
                    if (this.currentTool === 'zoom') {
                        this.startZoom(e);
                    } else if (this.currentTool === 'pan') {
                        // Ya manejado arriba
                    } else if (this.currentTool === 'lasso' || this.currentTool === 'lasso-eraser') {
                        this.startLasso(e);
                    } else if (this.currentTool === 'fill') {
                        this.fillArea(e);
                    } else if (['brush', 'eraser', 'smudge'].includes(this.currentTool)) {
                        this.startDrawing(e);
                    }
                }
            }
            handlePointerMove(e) {
                // Solo actualizar preview si es herramienta de pincel
                if (['brush', 'eraser', 'smudge'].includes(this.currentTool)) {
                    this.updateBrushPreview(e);
                }
                if (this.isPanning) {
                    const dx = e.clientX - this.startPanX;
                    const dy = e.clientY - this.startPanY;
                    this.panX += dx;
                    this.panY += dy;
                    this.startPanX = e.clientX;
                    this.startPanY = e.clientY;
                    this.updateCanvasTransform();
                } else if (this.isZoomDragging) {
                    this.handleZoomDrag(e);
                } else if (this.isDrawing && ['brush', 'eraser', 'smudge'].includes(this.currentTool)) {
                    this.draw(e);
                } else if (this.isLassoDrawing && (this.currentTool === 'lasso' || this.currentTool === 'lasso-eraser')) {
                    this.drawLasso(e);
                } else if (this.isPinching && e.pointerType === 'touch') {
                    this.handlePinch(e);
                }
            }
            handlePointerUp(e) {
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvasContainer.style.cursor = this.currentTool === 'pan' ? 'grab' : 'crosshair';
                } else if (this.isZoomDragging) {
                    this.stopZoom();
                } else if (this.isLassoDrawing) {
                    this.stopLasso(e);
                } else if (this.isPinching) {
                    this.stopPinch();
                } else {
                    this.stopDrawing();
                }
            }
            handlePointerLeave(e) {
             if (!this.inputCanvas.hasPointerCapture(e.pointerId)) {
    this.stopDrawing();
    this.stopLasso();
}
this.stopPinch();
if (this.isPanning) {
    this.isPanning = false;
    this.canvasContainer.style.cursor = this.currentTool === 'pan' ? 'grab' : 'crosshair';
}
            }
            showFillSettings(e) {
                const panel = document.getElementById('fill-settings-panel');
                panel.style.display = 'block';
                panel.style.left = e.target.offsetLeft + 'px';
                panel.style.top = e.target.offsetTop + e.target.offsetHeight + 'px';
            }
            getMousePos(e) {
                const rect = this.canvasContainer.getBoundingClientRect();
                const scaleX = this.containerWidth / rect.width;
                const scaleY = this.containerHeight / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
            startDrawing(e) {
                if (!['brush', 'eraser', 'smudge'].includes(this.currentTool)) return;
                const pos = this.getMousePos(e);
                this.points = [pos];
                const layer = this.layers[this.activeLayerIndex];
                if (!layer.visible || (layer.locked && this.getPixelAlpha(layer.ctx, pos.x, pos.y) === 0)) return;
                this.saveState(layer);
                this.isDrawing = true;
                this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                this.inputCanvas.setPointerCapture(e.pointerId);
                // Para smudge (difuminar), aplicar blur inicial
                if (this.currentTool === 'smudge') {
                    const radius = this.brushSize / 2;
                    const kernelSize = Math.max(3, Math.floor(this.brushSize / 5));
                    this.blurRegion(layer.ctx, pos.x, pos.y, radius, this.currentOpacity / 100, kernelSize);
                }
            }
            getPixelAlpha(ctx, x, y) {
                const imageData = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1);
                return imageData.data[3];
            }
            draw(e) {
                if (!['brush', 'eraser', 'smudge'].includes(this.currentTool)) return;
                if (!this.isDrawing) return;
                const pos = this.getMousePos(e);
                this.points.push(pos);
                if (this.currentTool === 'eraser') {
                    this.handleEraserDraw();
                    return;
                }
                if (this.currentTool === 'smudge') {
                    const radius = this.brushSize / 2;
                    const kernelSize = Math.max(3, Math.floor(this.brushSize / 5));
                    this.blurRegion(this.layers[this.activeLayerIndex].ctx, pos.x, pos.y, radius, this.currentOpacity / 100, kernelSize);
                    return;
                }
                const smoothed = this.getSmoothedPoints();
                this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                this.inputCtx.globalCompositeOperation = 'source-over';
                this.inputCtx.save();
                if (this.realTimeOpacity) {
                    this.inputCtx.globalAlpha = this.currentOpacity / 100;
                }
                this.inputCtx.lineWidth = this.brushSize;
                this.inputCtx.strokeStyle = this.color;
                this.drawPath(this.inputCtx, smoothed);
                this.inputCtx.restore();
            }
            stopDrawing() {
                if (!this.isDrawing) return;
                this.isDrawing = false;
                const layer = this.layers[this.activeLayerIndex];
                if (!layer.visible) {
                    this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                    this.points = [];
                    return;
                }
                if (this.currentTool === 'eraser') {
                    if (this.points.length === 1) {
                        layer.ctx.globalCompositeOperation = 'destination-out';
                        layer.ctx.beginPath();
                        layer.ctx.arc(this.points[0].x, this.points[0].y, this.brushSize / 2, 0, 2 * Math.PI);
                        layer.ctx.save();
                        layer.ctx.globalAlpha = this.currentOpacity / 100;
                        layer.ctx.fill();
                        layer.ctx.restore();
                        layer.ctx.globalCompositeOperation = 'source-over';
                    }
                    this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                    if (this.isLayersPanelOpen) {
                        this.updateLayerUI();
                    }
                    this.points = [];
                    return;
                }
                if (this.currentTool === 'smudge') {
                    this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                    if (this.isLayersPanelOpen) {
                        this.updateLayerUI();
                    }
                    this.points = [];
                    return;
                }
                if (this.points.length < 2) {
                    this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                    this.points = [];
                    return;
                }
                const smoothed = this.getSmoothedPoints();
                // Si locked, usar source-atop para dibujar solo sobre opacidades existentes
                layer.ctx.globalCompositeOperation = layer.locked ? 'source-atop' : 'source-over';
                layer.ctx.save();
                layer.ctx.globalAlpha = this.currentOpacity / 100;
                layer.ctx.lineCap = 'round';
                layer.ctx.lineJoin = 'round';
                layer.ctx.lineWidth = this.brushSize;
                layer.ctx.strokeStyle = this.color;
                this.drawPath(layer.ctx, smoothed);
                layer.ctx.restore();
                layer.ctx.globalCompositeOperation = 'source-over';
                this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                if (this.isLayersPanelOpen) {
                    this.updateLayerUI();
                }
                this.points = [];
            }
            boxBlur(imageData, kernelSize) {
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const output = new Uint8ClampedArray(pixels.length);
                const half = Math.floor(kernelSize / 2);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let r = 0, g = 0, b = 0, a = 0, count = 0;
                        for (let ky = -half; ky <= half; ky++) {
                            for (let kx = -half; kx <= half; kx++) {
                                const px = x + kx;
                                const py = y + ky;
                                if (px >= 0 && px < width && py >= 0 && py < height) {
                                    const i = (py * width + px) * 4;
                                    r += pixels[i];
                                    g += pixels[i + 1];
                                    b += pixels[i + 2];
                                    a += pixels[i + 3];
                                    count++;
                                }
                            }
                        }
                        const i = (y * width + x) * 4;
                        output[i] = Math.round(r / count);
                        output[i + 1] = Math.round(g / count);
                        output[i + 2] = Math.round(b / count);
                        output[i + 3] = Math.round(a / count);
                    }
                }
                return new ImageData(output, width, height);
            }
            blurRegion(ctx, centerX, centerY, radius, strength, kernelSize) {
                const x = Math.floor(centerX - radius);
                const y = Math.floor(centerY - radius);
                const w = Math.floor(radius * 2);
                const h = Math.floor(radius * 2);
                if (w <= 0 || h <= 0) return;
                let imageData;
                try {
                    imageData = ctx.getImageData(x, y, w, h);
                } catch (e) {
                    return; // Fuera de l칤mites
                }
                const blurredData = this.boxBlur(imageData, kernelSize);
                const originalPixels = imageData.data;
                const blurredPixels = blurredData.data;
                for (let i = 0; i < originalPixels.length; i += 4) {
                    originalPixels[i] = originalPixels[i] * (1 - strength) + blurredPixels[i] * strength;
                    originalPixels[i + 1] = originalPixels[i + 1] * (1 - strength) + blurredPixels[i + 1] * strength;
                    originalPixels[i + 2] = originalPixels[i + 2] * (1 - strength) + blurredPixels[i + 2] * strength;
                    originalPixels[i + 3] = originalPixels[i + 3] * (1 - strength) + blurredPixels[i + 3] * strength;
                }
                ctx.putImageData(imageData, x, y);
            }
            startLasso(e) {
                if (this.currentTool !== 'lasso' && this.currentTool !== 'lasso-eraser') return;
                const pos = this.getMousePos(e);
                this.lassoPoints = [pos];
                this.isLassoDrawing = true;
               this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
this.inputCanvas.setPointerCapture(e.pointerId);
            }
            drawLasso(e) {
                if (this.currentTool !== 'lasso' && this.currentTool !== 'lasso-eraser') return;
                if (!this.isLassoDrawing) return;
                const pos = this.getMousePos(e);
                this.lassoPoints.push(pos);
                this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                // Dibujar el relleno en tiempo real
                if (this.lassoPoints.length >= 2) {
                    this.inputCtx.beginPath();
                    this.inputCtx.moveTo(this.lassoPoints[0].x, this.lassoPoints[0].y);
                    for (let i = 1; i < this.lassoPoints.length; i++) {
                        this.inputCtx.lineTo(this.lassoPoints[i].x, this.lassoPoints[i].y);
                    }
                    this.inputCtx.closePath();
                    // Rellenar con el color actual (para lasso normal) o transparente (para borrador)
                    this.inputCtx.save();
                    if (this.realTimeOpacity) {
                        this.inputCtx.globalAlpha = this.currentOpacity / 100;
                    }
      if (this.currentTool === 'lasso') {
    this.inputCtx.fillStyle = this.realTimeOpacity ? this.color : this.color + '80';
    this.inputCtx.fill();
} else if (this.currentTool === 'lasso-eraser') {
    this.inputCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    this.inputCtx.fill();
}
                    this.inputCtx.restore();
                    // Dibujar el borde
                    let strokeColor = '#ff0000';
                    if (this.currentTool === 'lasso') {
                        if (this.lassoLineStyle === 'default') {
                            strokeColor = this.color;
                        } else {
                            strokeColor = this.lassoLineCustomColor;
                        }
                    }
                    this.inputCtx.strokeStyle = strokeColor;
                    this.inputCtx.setLineDash([5, 5]);
                    this.inputCtx.lineWidth = 2;
                    this.inputCtx.stroke();
                    this.inputCtx.setLineDash([]);
                }
            }
            getContrastColorAt(x, y) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 1;
                tempCanvas.height = 1;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.fillStyle = '#f0f0f0';
                tempCtx.fillRect(0, 0, 1, 1);
                for (let i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].visible && i <= this.activeLayerIndex) {
                        tempCtx.save();
                        tempCtx.globalAlpha = this.layers[i].opacity;
                        tempCtx.drawImage(this.layers[i].canvas, Math.floor(x), Math.floor(y), 1, 1, 0, 0, 1, 1);
                        tempCtx.restore();
                    }
                }
                const pixel = tempCtx.getImageData(0, 0, 1, 1).data;
                const brightness = (pixel[0] * 0.299 + pixel[1] * 0.587 + pixel[2] * 0.114);
                return brightness > 128 ? '#000000' : '#ffffff';
            }
            stopLasso() {
                if (!this.isLassoDrawing || this.lassoPoints.length < 3) {
                    this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                    this.lassoPoints = [];
                    this.isLassoDrawing = false;
                    return;
                }
                this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                const layer = this.layers[this.activeLayerIndex];
                if (!layer.visible) {
                    this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                    this.lassoPoints = [];
                    this.isLassoDrawing = false;
                    return;
                }
                this.saveState(layer);
                layer.ctx.beginPath();
                layer.ctx.moveTo(this.lassoPoints[0].x, this.lassoPoints[0].y);
                for (let i = 1; i < this.lassoPoints.length; i++) {
                    layer.ctx.lineTo(this.lassoPoints[i].x, this.lassoPoints[i].y);
                }
                layer.ctx.closePath();
                layer.ctx.save();
                layer.ctx.globalAlpha = this.currentOpacity / 100;
                if (this.currentTool === 'lasso') {
                    layer.ctx.globalCompositeOperation = layer.locked ? 'source-atop' : 'source-over';
                    layer.ctx.fillStyle = this.color;
                    layer.ctx.fill();
                    layer.ctx.globalCompositeOperation = 'source-over';
                } else if (this.currentTool === 'lasso-eraser') {
                    layer.ctx.globalCompositeOperation = 'destination-out';
                    layer.ctx.fill();
                    layer.ctx.globalCompositeOperation = 'source-over';
                }
                layer.ctx.restore();
                this.inputCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                if (this.isLayersPanelOpen) {
                    this.updateLayerUI();
                }
                this.lassoPoints = [];
                this.isLassoDrawing = false;
            }
            fillArea(e) {
                if (this.currentTool !== 'fill') return;
                const pos = this.getMousePos(e);
                const layer = this.layers[this.activeLayerIndex];
                if (!layer.visible || (layer.locked && this.getPixelAlpha(layer.ctx, pos.x, pos.y) === 0)) return;
                this.saveState(layer);
                const x = Math.floor(pos.x);
                const y = Math.floor(pos.y);
                const imageData = layer.ctx.getImageData(0, 0, this.containerWidth, this.containerHeight);
                const targetColor = this.getPixelColor(imageData, x, y);
                const fillColor = this.hexToRgb(this.color);
                this.floodFill(layer.ctx, x, y, targetColor, fillColor, this.fillTolerance, this.fillAlphaTolerance);
                if (this.isLayersPanelOpen) {
                    this.updateLayerUI();
                }
            }
            getPixelColor(imageData, x, y) {
                const index = (y * imageData.width + x) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }
            colorsMatch(color1, color2, tolerance, alphaTolerance) {
                const dr = Math.abs(color1.r - color2.r);
                const dg = Math.abs(color1.g - color2.g);
                const db = Math.abs(color1.b - color2.b);
                const da = Math.abs(color1.a - color2.a);
                return dr <= tolerance && dg <= tolerance && db <= tolerance && da <= alphaTolerance;
            }
            floodFill(ctx, startX, startY, targetColor, fillColor, tolerance, alphaTolerance) {
                const imageData = ctx.getImageData(0, 0, this.containerWidth, this.containerHeight);
                const pixels = imageData.data;
                const width = this.containerWidth;
                const height = this.containerHeight;
                const stack = [[startX, startY]];
                const visited = new Set();
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const index = (y * width + x) * 4;
                    if (x < 0 || x >= width || y < 0 || y >= height) continue;
                    if (visited.has(`${x},${y}`)) continue;
                    const currentColor = {
                        r: pixels[index],
                        g: pixels[index + 1],
                        b: pixels[index + 2],
                        a: pixels[index + 3]
                    };
                    if (this.colorsMatch(currentColor, targetColor, tolerance, alphaTolerance)) {
                        pixels[index] = fillColor.r;
                        pixels[index + 1] = fillColor.g;
                        pixels[index + 2] = fillColor.b;
                        pixels[index + 3] = 255;
                        visited.add(`${x},${y}`);
                        stack.push([x + 1, y]);
                        stack.push([x - 1, y]);
                        stack.push([x, y + 1]);
                        stack.push([x, y - 1]);
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            }
            handleEraserDraw() {
                if (this.currentTool !== 'eraser') return;
                const layer = this.layers[this.activeLayerIndex];
                if (!layer.visible) return;
                const smoothed = this.getSmoothedPoints();
                layer.ctx.globalCompositeOperation = 'destination-out';
                layer.ctx.lineCap = 'round';
                layer.ctx.lineJoin = 'round';
                layer.ctx.lineWidth = this.brushSize;
                layer.ctx.save();
                layer.ctx.globalAlpha = this.currentOpacity / 100;
                this.drawPath(layer.ctx, smoothed);
                layer.ctx.restore();
                layer.ctx.globalCompositeOperation = 'source-over';
            }
            updateBrushPreview(e) {
                if (!['brush', 'eraser', 'smudge'].includes(this.currentTool)) return;
                if (this.isDrawing || this.isLassoDrawing || this.isZoomDragging) return;
                const pos = this.getMousePos(e);
                this.brushPreviewCtx.clearRect(0, 0, this.containerWidth, this.containerHeight);
                if (this.currentTool === 'smudge') {
                    this.brushPreviewCtx.fillStyle = 'rgba(128, 128, 128, 0.3)';
                    this.brushPreviewCtx.beginPath();
                    this.brushPreviewCtx.arc(pos.x, pos.y, this.brushSize / 2, 0, 2 * Math.PI);
                    this.brushPreviewCtx.fill();
                } else {
                    this.brushPreviewCtx.beginPath();
                    this.brushPreviewCtx.arc(pos.x, pos.y, this.brushSize / 2, 0, 2 * Math.PI);
                    this.brushPreviewCtx.strokeStyle = this.currentTool === 'eraser' ? '#ffffff' : this.color;
                    this.brushPreviewCtx.lineWidth = 1;
                    this.brushPreviewCtx.stroke();
                }
            }
            toggleLayersPanel() {
                this.isLayersPanelOpen = !this.isLayersPanelOpen;
                const panel = document.getElementById('layers-panel');
                panel.style.display = this.isLayersPanelOpen ? 'block' : 'none';
                if (this.isLayersPanelOpen) {
                    this.updateLayerUI();
                }
            }
            updateDisplays() {
                document.getElementById('size-display').textContent = this.brushSize;
                document.getElementById('stab-display').textContent = this.stabilizer;
                document.getElementById('tolerance-display').textContent = this.fillTolerance;
                document.getElementById('alpha-tolerance-display').textContent = this.fillAlphaTolerance;
                if (['brush', 'eraser', 'lasso', 'lasso-eraser', 'smudge'].includes(this.currentTool)) {
                    document.getElementById('opacity-display').textContent = this.currentOpacity;
                }
            }
            updateCanvasTransform() {
                this.canvasContainer.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoom})`;
            }
        }
        const illustrator = new DigitalIllustrator();
    </script>
</body>
</html>
